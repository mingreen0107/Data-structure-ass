// 이중연결리스트로 풀어보기
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// 이름과 관련있는 노드 생성
typedef struct Node { 
	struct Node* prev;
	char name[10];
	struct Node* next;
} Node;
Node* head;
Node* tail;

// 이름을 저장하는 노드 생성
Node* newNode(char *inputName) {
	Node* inputname;

	inputname = (Node*)malloc(sizeof(Node));
	inputname = (char*)malloc(strlen(inputName) + 1);
	strcpy(inputname->name, inputName); // 노드에 이름을 넣어주깅
	inputname->next = NULL;

	return inputname;
}
// 초기화 하는 함수
void init() {
	head = (Node*)malloc(sizeof(Node));
	tail = (Node*)malloc(sizeof(Node));
	*head->name = 'NULL'; // 초기화 하는 법이 이게 마za?
	*tail->name = 'NULL'; // prev랑 next는 왜 초기화를 안 해도 될까?

	// head와 tail이 서로를 가르키도록 하는 과정
	head->next = tail; 
	head->prev = head;
	tail->next = tail;
	tail->prev = head;
}
// 이어주는 노드
void connect_node(Node* new) { 
	Node* connect = newNode(new);
	Node* p;
	p = tail;

	p->prev->next = connect;
	connect->prev = p->prev;
	p->prev = connect;
	connect->next = p;
}
// 대표학생의 종이뽑기
int randset(int n) { 
	int randpick = rand() % n + 1;

	return randpick;
}
// 함수 시작 위치와 뽑은 수로 재배치
// 이게 뽑은자리 전의 데이터는 가져올 수 없음
Node* relocation_node(Node** p2head, int picknum) {
	Node* relocation;
	Node* p = head; // 이렇게 주는 것이 맞나?
	int i = 1;

	if (i == picknum) {
		relocation->prev = p;
	}
	else {
		i++;
		p = p->next;
	}
	printf("재배치 후 학생들의 자리 :\n");
	while (relocation->next != tail) {
		printf("%s ", relocation->name);
		relocation = relocation->next;
	}
	printf("%s", relocation->name);
}
// 제거 될 위치에 있는 학생을 출력하는 함수
Node* remove_node(int picknum) {
	Node* p;
	char pickstu[10];
	int i = 0;
	
	p = head;
	while (p->next != tail) {
		if (i == picknum + 1) {
			strcpy(pickstu, p->name);
			break;
		}
		else {
			i++;
			p = p->next;
		}
	}
	if (p->next == tail) {
		printf("최종 남은 학생 : %s", ?); // 값을 어떻게 넘겨줘야하지?
	}
	else {
		printf("제거 된 학생 : %s", pickstu);
	}
	free(p);
}
// 남은 학생들을 출력하는 함수
Node* remain_node(Node** p2head) {
	Node* p;
	p = head;
	
	while (p->next != tail) {
		printf("%s ", p->name);
		p = p->next;
	}
	printf("%s", p->name);
	free(p);
}
int main() {

	Node* p, * relocation;
	char inputName[10];
	int sumstu, rand, n;

	printf("학생의 이름을 입력하시오. (0을 입력하면 종료)\n");
	while (1) {

		scanf("%s", inputName);

		if (inputName[0] == '0')
			break;
		else {
			p = newNode(inputName);
			connect_node(p);
		}
	}
	printf("\n총 학생수를 입력하시오. (대표학생의 종이뽑기)\n");
	scanf("%d", &sumstu);
	rand = randset(sumstu);
	printf("-> %d번 자리부터 재배치", rand);

	printf("재배치 후 학생들의 자리\n");
	relocation = relocation_node(&head, rand);
	while (relocation) {
		printf("%s ", relocation);
		relocation = relocation->next;
	}

	printf("\n\n제거될 자리를 입력하시오.\n");
	scanf("%d", &n);

	// 제거 된 학생의 이름 출력하는 함수
	remove_node(rand);

	// 남은 학생을 출력하는 함수
	printf("\n남은 학생 이름 : ");
	remain_node(&head);

	free(p);
	free(relocation);
}